<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-unpackwxError" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/22/unpackwxError/" class="article-date">
  <time datetime="2022-04-22T02:54:08.000Z" itemprop="datePublished">2022-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/22/unpackwxError/">【工具】【小程序】wxUnpacker 工具“SyntaxError： Illegal return statement” 错误</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前提到的微信小程序解包工具，在部分小程序上无法正常反编译，表现在输出结果上为得不到页面 wxml 及 wxss 文件。</p>
<h1 id="Error-解决"><a href="#Error-解决" class="headerlink" title="Error 解决"></a>Error 解决</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>脚本解包过程中断，控制台输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vm.js:519</span><br><span class="line"></span><br><span class="line">return function(env,dd,global)&#123;$gwxc=0;var root=&#123;&quot;tag&quot;:&quot;wx-page&quot;&#125;;root.children=[]</span><br><span class="line"></span><br><span class="line">^^^^^^</span><br><span class="line"></span><br><span class="line">SyntaxError: Illegal return statement</span><br><span class="line">    at VMScript.compile (/home/wq57885/wxappUnpacker/node_modules/vm2/lib/main.js:80:20)</span><br><span class="line">    at VM.run (/home/wq57885/wxappUnpacker/node_modules/vm2/lib/main.js:215:10)</span><br><span class="line">    at z (/home/wq57885/wxappUnpacker/wuWxml.js:366:7)</span><br><span class="line">    at z (/home/wq57885/wxappUnpacker/wuRestoreZ.js:244:17)</span><br><span class="line">    at catchZGroup (/home/wq57885/wxappUnpacker/wuRestoreZ.js:15:2)</span><br><span class="line">    at catchZ (/home/wq57885/wxappUnpacker/wuRestoreZ.js:19:29)</span><br><span class="line">    at getZ (/home/wq57885/wxappUnpacker/wuRestoreZ.js:244:2)</span><br><span class="line">    at wu.get.code (/home/wq57885/wxappUnpacker/wuWxml.js:354:3)</span><br><span class="line">    at ioLimit.runWithCb (/home/wq57885/wxappUnpacker/wuLib.js:80:8)</span><br><span class="line">    at agent (/home/wq57885/wxappUnpacker/wuLib.js:54:14)</span><br></pre></td></tr></table></figure>

<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>总的来说这个问题是由于小程序包结构随版本更新有变化，导致前一位大佬的 wxUnpacker 没法正确解析 wxml 及 wxss 文件，为此 19 年另一位大佬提供了解决工具<a target="_blank" rel="noopener" href="https://github.com/larack8/wxappUnpacker">larack8</a>。</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>拜读了大佬解决问题的逻辑，主要如下</p>
<h3 id="原工具解析思路"><a href="#原工具解析思路" class="headerlink" title="原工具解析思路"></a>原工具解析思路</h3><p>所有在 wxapkg 包中的 html 文件都调用了setCssToHead函数，其代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">var setCssToHead = function(file, _xcInvalid) &#123;</span><br><span class="line">    var Ca = &#123;&#125;;</span><br><span class="line">    var _C = [...arrays...];</span><br><span class="line">    function makeup(file, suffix) &#123;</span><br><span class="line">        var _n = typeof file === &quot;number&quot;;</span><br><span class="line">        if (_n &amp;&amp; Ca.hasOwnProperty(file)) return &quot;&quot;;</span><br><span class="line">        if (_n) Ca[file] = 1;</span><br><span class="line">        var ex = _n ? _C[file] : file;</span><br><span class="line">        var res = &quot;&quot;;</span><br><span class="line">        for (var i = ex.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            var content = ex[i];</span><br><span class="line">            if (typeof content === &quot;object&quot;) &#123;</span><br><span class="line">                var op = content[0];</span><br><span class="line">                if (op == 0) res = transformRPX(content[1]) + &quot;px&quot; + res; else if (op == 1) res = suffix + res; else if (op == 2) res = makeup(content[1], suffix) + res;</span><br><span class="line">            &#125; else res = content + res;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    return function(suffix, opt) &#123;</span><br><span class="line">        if (typeof suffix === &quot;undefined&quot;) suffix = &quot;&quot;;</span><br><span class="line">        if (opt &amp;&amp; opt.allowIllegalSelector != undefined &amp;&amp; _xcInvalid != undefined) &#123;</span><br><span class="line">            if (opt.allowIllegalSelector) console.warn(&quot;For developer:&quot; + _xcInvalid); else &#123;</span><br><span class="line">                console.error(_xcInvalid + &quot;This wxss file is ignored.&quot;);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Ca = &#123;&#125;;</span><br><span class="line">        css = makeup(file, suffix);</span><br><span class="line">        var style = document.createElement(&quot;style&quot;);</span><br><span class="line">        var head = document.head || document.getElementsByTagName(&quot;head&quot;)[0];</span><br><span class="line">        style.type = &quot;text/css&quot;;</span><br><span class="line">        if (style.styleSheet) &#123;</span><br><span class="line">            style.styleSheet.cssText = css;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            style.appendChild(document.createTextNode(css));</span><br><span class="line">        &#125;</span><br><span class="line">        head.appendChild(style);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>阅读这段代码可知，它把 wxss 代码拆分成几段数组，数组中的内容可以是一段将要作为 css 文件的字符串，也可以是一个表示 这里要添加一个公共后缀 或 这里要包含另一段代码 或 要将以 wxss 专供的 rpx 单位表达的数字换算成能由浏览器渲染的 px 单位所对应的数字 的数组。</p>
<p>同时，它还将所有被@import引用的 wxss 文件所对应的数组内嵌在该函数中的 _C 变量中。</p>
<p>我们可以修改setCssToHead，然后执行所有的setCssToHead，第一遍先判断出 _C 变量中所有的内容是哪个要被引用的 wxss 提供的，第二遍还原所有的 wxss。值得注意的是，可能出于兼容性原因，微信为很多属性自动补上含有-webkit-开头的版本，另外几乎所有的 tag 都加上了wx-前缀，并将page变成了body。通过一些 CSS 的 AST ，例如 CSSTree，我们可以去掉这些东西。</p>
<p><strong>wxs</strong><br>在 page-frame.html ( 或 app-wxss.js ) 中，我们找到了这样的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f_[&#x27;a/comm.wxs&#x27;] = nv_require(&quot;p_a/comm.wxs&quot;);</span><br><span class="line">function np_0()&#123;var nv_module=&#123;nv_exports:&#123;&#125;&#125;;nv_module.nv_exports = (&#123;nv_bar:nv_some_msg,&#125;);return nv_module.nv_exports;&#125;</span><br><span class="line"></span><br><span class="line">f_[&#x27;b/comm.wxs&#x27;] = nv_require(&quot;p_b/comm.wxs&quot;);</span><br><span class="line">function np_1()&#123;var nv_module=&#123;nv_exports:&#123;&#125;&#125;;nv_module.nv_exports = (&#123;nv_bar:nv_some_msg,&#125;);return nv_module.nv_exports;&#125;</span><br><span class="line"></span><br><span class="line">f_[&#x27;b/index.wxml&#x27;]=&#123;&#125;;</span><br><span class="line">f_[&#x27;b/index.wxml&#x27;][&#x27;foo&#x27;] =nv_require(&quot;m_b/index.wxml:foo&quot;);</span><br><span class="line">function np_2()&#123;var nv_module=&#123;nv_exports:&#123;&#125;&#125;;var nv_some_msg = &quot;hello world&quot;;nv_module.nv_exports = (&#123;nv_msg:nv_some_msg,&#125;);return nv_module.nv_exports;&#125;</span><br><span class="line">f_[&#x27;b/index.wxml&#x27;][&#x27;some_comms&#x27;] =f_[&#x27;b/comm.wxs&#x27;] || nv_require(&quot;p_b/comm.wxs&quot;);</span><br><span class="line">f_[&#x27;b/index.wxml&#x27;][&#x27;some_comms&#x27;]();</span><br><span class="line">f_[&#x27;b/index.wxml&#x27;][&#x27;some_commsb&#x27;] =f_[&#x27;a/comm.wxs&#x27;] || nv_require(&quot;p_a/comm.wxs&quot;);</span><br><span class="line">f_[&#x27;b/index.wxml&#x27;][&#x27;some_commsb&#x27;]();</span><br></pre></td></tr></table></figure>

<p>可以看出微信将内嵌和外置的 wxs 都转译成np_%d函数，并由f_数组来描述他们。转译的主要变换是调用的函数名称都加上了nv_前缀。在不严谨的场合，我们可以直接通过文本替换去除这些前缀。</p>
<p><strong>wxml</strong><br>相比其他内容，这一段比较复杂，因为微信将原本 类 xml 格式的 wxml 文件直接编译成了 js 代码放入 page-frame.html ( 或 app-wxss.js ) 中，之后通过调用这些代码来构造 virtual-dom，进而渲染网页。 首先，微信将所有要动态计算的变量放在了一个由函数构造的z数组中，构造部分代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function(z)&#123;var a=11;function Z(ops)&#123;z.push(ops)&#125;</span><br><span class="line">Z([3,&#x27;index&#x27;]);</span><br><span class="line">Z([[8],&#x27;text&#x27;,[[4],[[5],[[5],[[5],[1,1]],[1,2]],[1,3]]]]);</span><br><span class="line">&#125;)(z);</span><br></pre></td></tr></table></figure>

<p>其实可以将[[id],xxx,yyy]看作由指令与操作数的组合。注意每个这样的数组作为指令所产生的结果会作为外层数组中的操作数，这样可以构成一个树形结构。通过将递归计算的过程改成拼接源代码字符串的过程，我们可以还原出每个数组所对应的实际内容（值得注意的是，由于微信的Token解析程序采用了贪心算法，我们必须将连续的}翻译为} }而非}}，否则会被误认为是Mustache的结束符）。下文中，将这个数组中记为z。</p>
<p>然后，对于 wxml 文件的结构，可以将每种可能的 js 语句拆分成 指令 来分析，这里可以用到 Esprima 这样的 js 的 AST 来简化识别操作，可以很容易分析出以下内容，例如:</p>
<ul>
<li>var {name}=_n(‘{tag}’) 创建名称为{name}， tag 为{tag}的节点。</li>
<li>_r({name},’{attrName}’,{id},e,s,gg) 将{name}的{attrName}属性修改为z[{id}]的值。</li>
<li>_({parName},{name}) 将{name}作为{parName}的子节点。</li>
<li>var {name}=_o({id},..,..,..) 创建名称为{name}，内容为z[{id}]的文本节点。</li>
<li>var {name}=_v() 创建名称为{name}的虚节点( wxml 里恰好提供了功能相当的虚结点block, 这句话相当于var {name}=_n(‘block’))。</li>
<li>var {name}=_m(‘{tag}’,[‘{attrName1}’,{id1},’{attrName2}’,{id2},…],[],..,..,..) 创建名称为{name}， tag 为{tag}的节点，同时将{attrNameX}属性修改为z[f({idX})]的值(f定义为{idX}与{base}的和；{base}初始为0，f返回的第一个正值后{base}即改为该返回值；若返回负值，表示该属性无值)。</li>
<li>return {name} 名称为{name}的节点设为主节点。</li>
<li>cs.*** 调试用语句，无视之。</li>
</ul>
<p>此外wx:if结构和wx:for可做递归处理。例如，对于如下wx:if结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var &#123;name&#125;=_v()</span><br><span class="line">_(&#123;parName&#125;,&#123;name&#125;)</span><br><span class="line">if(_o(&#123;id1&#125;,e,s,gg))&#123;oD.wxVkey=1</span><br><span class="line">//content1</span><br><span class="line">&#125;</span><br><span class="line">else if(_o(&#123;id2&#125;,e,s,gg))&#123;oD.wxVkey=2</span><br><span class="line">//content2</span><br><span class="line">&#125;</span><br><span class="line">else&#123;oD.wxVkey=3</span><br><span class="line">//content3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于将以下节点放入{parName}节点下(z[{id1}]应替换为对应的z数组中的值)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:if=&quot;z[&#123;id1&#125;]&quot;&gt;</span><br><span class="line">    &lt;!--content1--&gt;</span><br><span class="line">&lt;/block&gt;</span><br><span class="line">&lt;block wx:elif=&quot;z[&#123;id2&#125;]&quot;&gt;</span><br><span class="line">    &lt;!--content2--&gt;</span><br><span class="line">&lt;/block&gt;</span><br><span class="line">&lt;block wx:else&gt;</span><br><span class="line">    &lt;!--content3--&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure>

<p>具体实现中可以将递归时创建好多个block，调用子函数时指明将放入{name}下(_({name},{son}))识别为放入对应{block}下。wx:for也可类似处理，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体实现中可以将递归时创建好多个block，调用子函数时指明将放入&#123;name&#125;下(_(&#123;name&#125;,&#123;son&#125;))识别为放入对应&#123;block&#125;下。wx:for也可类似处理，例如：</span><br></pre></td></tr></table></figure>

<p>对应(z[{id1}]应替换为对应的z数组中的值)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;z[&#123;id&#125;]&#125;&quot; wx:for-item=&quot;&#123;item&#125;&quot; wx:for-index=&quot;&#123;index&#125;&quot; wx:key=&quot;&#123;key&#125;&quot;&gt;</span><br><span class="line">    &lt;!--content--&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<p>调用子函数时指明将放入{fakeRoot}下(_({fakeRoot},{son}))识别为放入{name}下。除此之外，有时我们还要将一组代码标记为一个指令，例如下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var lK=_v()</span><br><span class="line">_(&#123;parName&#125;,lK)</span><br><span class="line">var aL=_o(&#123;isId&#125;,e,s,gg)</span><br><span class="line">var tM=_gd(x[0],aL,e_,d_)</span><br><span class="line">if(tM)&#123;</span><br><span class="line">var eN=_1(&#123;dataId&#125;,e,s,gg) || &#123;&#125;</span><br><span class="line">var cur_globalf=gg.f</span><br><span class="line">lK.wxXCkey=3</span><br><span class="line">tM(eN,eN,lK,gg)</span><br><span class="line">gg.f=cur_globalf</span><br><span class="line">&#125;</span><br><span class="line">else _w(aL,x[0],11,26)</span><br></pre></td></tr></table></figure>

<p>对应于{parName}下添加如下节点:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;template is=&quot;z[&#123;isId&#125;]&quot; data=&quot;z[&#123;dataId&#125;]&quot;&gt;&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>还有import和include的代码比较分散，但其实只要抓住重点的一句话就可以了，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var &#123;name&#125;=e_[x[&#123;to&#125;]].i</span><br><span class="line">//Other code</span><br><span class="line">_ai(&#123;name&#125;,x[&#123;from&#125;],e_,x[&#123;to&#125;],..,..)</span><br><span class="line">//Other code</span><br><span class="line">&#123;name&#125;.pop()</span><br></pre></td></tr></table></figure>

<p>对应与(其中的x是直接定义在 page-frame.html ( 或 app-wxss.js ) 中的字符串数组)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;import src=&quot;x[&#123;from&#125;]&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>而include类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var &#123;name&#125;=e_[x[0]].j</span><br><span class="line">//Other code</span><br><span class="line">_ic(x[&#123;from&#125;],e_,x[&#123;to&#125;],..,..,..,..);</span><br><span class="line">//Other code</span><br><span class="line">&#123;name&#125;.pop()</span><br></pre></td></tr></table></figure>

<p>对应与：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;include src=&quot;x[&#123;from&#125;]&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到我们可以在处理时忽略前后两句话，把中间的_ic和_ai处理好就行了。通过解析 js 把 wxml 大概结构还原后，可能相比编译前的 wxml 显得臃肿，可以考虑自动简化，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;block wx:if=&quot;xxx&quot;&gt;</span><br><span class="line">    &lt;view&gt;</span><br><span class="line">        &lt;!--content--&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure>

<p>可简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:if=&quot;xxx&quot;&gt;</span><br><span class="line">    &lt;!--content--&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure>

<h3 id="更新后"><a href="#更新后" class="headerlink" title="更新后"></a>更新后</h3><p>wcc-v0.5vv_20180626_syb_zp后通过只加载z数组中需要的部分来提高小程序运行速度，这也会导致仅考虑到上述内容的解包程序解包失败，这一更新的主要内容如下：</p>
<ul>
<li>增加z数组的函数:_rz _2z _mz _1z _oz</li>
<li>在每个函数头部增加了var z=gz$gwx_{$id}()，来标识使用的z数组id</li>
<li>原有的z数组不再存在</li>
<li>z数组已以下固定格式出现：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function gz$gwx_&#123;$id&#125;()&#123;</span><br><span class="line">if( __WXML_GLOBAL__.ops_cached.$gwx_&#123;$id&#125;)return __WXML_GLOBAL__.ops_cached.$gwx_&#123;$id&#125;</span><br><span class="line">__WXML_GLOBAL__.ops_cached.$gwx_&#123;$id&#125;=[];</span><br><span class="line">(function(z)&#123;var a=11;function Z(ops)&#123;z.push(ops)&#125;</span><br><span class="line"></span><br><span class="line">//... (Z(&#123;$content&#125;))</span><br><span class="line"></span><br><span class="line">&#125;)(__WXML_GLOBAL__.ops_cached.$gwx_&#123;$id&#125;);return __WXML_GLOBAL__.ops_cached.$gwx_&#123;$id&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述变更，将获取z数组处修改并添加对_rz _2z _mz _1z _oz的支持即可。需要注意的是开发版的z数组转为如下结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(z)&#123;var a=11;function Z(ops,debugLine)&#123;z.push([&#x27;11182016&#x27;,ops,debugLine])&#125;</span><br><span class="line">//...</span><br><span class="line">&#125;)//...</span><br></pre></td></tr></table></figure>

<p>探测到为开发版后应将获取到的z数组仅保留数组中的第二项。以及含分包的子包采用 gz$gwx{$subPackageId}_{$id} 命名，其中{$subPackageId}是一个数字。另外还需要注意，template的 var z=gz$gwx_{$id} 在try块外。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其余一些博客提到利用 larack8 大佬的工具解决问题后，还存在找不到 node 模块的问题，他们给的解决方案相同，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g n</span><br><span class="line">n latest</span><br><span class="line">npm update -g</span><br></pre></td></tr></table></figure>
<p>然后再把所有需要的包 install 一遍。</p>
<p>这边用这个方法并没有解决问题，其次私以为该错误的根本问题还是 node 环境本身，问题在nodejs怎么查找模块上。</p>
<ul>
<li>首先，要知道 npm 全局安装到底把模块安装到了哪个目录下面。在终端运行npm prefix -g命令会打印出安装路径。而nodejs查找模块是在module.paths目录列表下面查找的。</li>
<li>所以，一种解决方案是在程序中将npm全局安装路径添加到module.paths中。module.paths.push(‘全局安装路径’)。然后再测试可行。这种方案只对当前js有效。</li>
<li>另一种是添加环境变量NODE_PATH，值就设置成全局安装路径。如图中所示，添加后测试可行。</li>
<li>其实，添加环境变量NODE_PATH后，我们再去查看module.paths时会发现环境变量中的路径也已经在module.paths中了。所以，最方便的解决办法就是：npm prefix -g 找到全局安装的路径，然后添加到环境变量NODE_PATH中。</li>
</ul>
<p>解决 require 问题之后再统一安装 wxUnpacker-larack8 ver 需要的模块即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install uglify-es --save</span><br><span class="line">npm install esprima  --save</span><br><span class="line">npm install css-tree  --save</span><br><span class="line">npm install cssbeautify --save</span><br><span class="line">npm install vm2  --save</span><br><span class="line">npm install uglify-es  --save</span><br><span class="line">npm install js-beautify  --save</span><br><span class="line">npm install escodegen  --save</span><br><span class="line">npm install cheerio  --save</span><br></pre></td></tr></table></figure>


<p>参考资料<br><a target="_blank" rel="noopener" href="https://github.com/larack8/wxappUnpacker">https://github.com/larack8/wxappUnpacker</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wq57885/article/details/101113017">https://blog.csdn.net/wq57885/article/details/101113017</a><br><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/2d5afd6937ad7785a2e28e98.html">https://jingyan.baidu.com/article/2d5afd6937ad7785a2e28e98.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/22/unpackwxError/" data-id="cl29vn5f00000ocwx7uvhe0o7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-apinath" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/04/15/apinath/" class="article-date">
  <time datetime="2022-04-15T01:12:12.000Z" itemprop="datePublished">2022-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/04/15/apinath/">【工具】【小程序】Apinat 工具原理解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近需要研究小程序 API 与调用到的 Android API 映射的问题，因此研究文章<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/abs/10.1145/3372297.3417255">CCS20 Haoran Lu</a>中 <a target="_blank" rel="noopener" href="https://sites.google.com/view/appinapp/automatic-analysis-tool">Apinat</a> 工具原理，并在微信 7.0.20 版本上实现。</p>
<h1 id="Apinat"><a href="#Apinat" class="headerlink" title="Apinat"></a>Apinat</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>在小程序中调用小程序 API，给出为实现该小程序 API，Java 层实现所用到的 Android API。作者开发本工具的目的是为了找到没有被微信小程序权限保护（scope.xxx）但是底层实现的 Android API被 AOSP dangerous permission 保护的那些小程序 API，这些小程序 API 被称为 Encapsulated API。详见前文<a target="_blank" rel="noopener" href="https://jwy630.github.io/2022/03/11/paperCCS20/">paper summary CCS20</a>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><p>Dispatch function（wx api）线程不直接调用 Android API，而是触发新的线程来调用 Android API，这么实现可能是出于不阻塞 dispatch 线程的考虑。<br>这就导致 dispatch 在 Thread1，实际执行的 Android APIs 在 Thread2。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>因此这就需要解决一个问题，就是处理多线程环境，将相关 threads 联系起来。</p>
<h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>通常 dispatch thread 会使用 Handler 机制（微信是这样，其他小程序平台如支付宝可能用的其他机制）来触发多线程。因此只需要基于 Handler 机制的推送及处理消息的原理就可以将线程联系起来。</p>
<ul>
<li>Triggering Thread：有 handler 实例，通过调用 handler.post(runnable) 来向消息队列提交一个 runnable</li>
<li>Handler thread：将 runnable 从队列拿出，并执行</li>
<li>如果 handler thread 中处理的 runnable 与 triggering thread 添加到队列的 runnable 相同，则可以将两个线程连接。</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>本实现基于前面提到的 <a target="_blank" rel="noopener" href="https://sites.google.com/view/appinapp/automatic-analysis-tool">Apinat</a> 提供的参考代码有修改，因为作者给出的代码没有指明在何版本微信上运行，因此笔者在参考工具框架基础上，结合微信 7.0.20 版本的小程序 API 调用的 Handler 实现而修改开发了适用 7.0.20 版本微信的 Apinat 工具，后续 8.x.x 版本应该也可用，只要 Handler 实现原理不变就适用。</p>
<ol>
<li><p>工具代码中 hook 的 apk 版本未给出，因此需要根据实际测试的微信 apk 版本修改。具体修改项：Xp_demo.java 中的 “com.tencent.mm.plugin.appbrand.jsapi.d” 类中被 hook 的是 “y” 方法，改方法是逆向对应的 7.0.20 中小程序 API invokeHandler 处理后必调方法。（原本这里是“n”，对应的是作者分析的未知版本的微信 apk）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(</span><br><span class="line">  //7.0.20 d 类的 y 方法</span><br><span class="line">  &quot;com.tencent.mm.plugin.appbrand.jsapi.d&quot;, lpparam.classLoader, &quot;y&quot;, String.class, String.class, int.class,// 被Hook函数的名称</span><br><span class="line">  new XC_MethodHook() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      protected void afterHookedMethod(MethodHookParam param)</span><br><span class="line">              throws Throwable &#123;</span><br><span class="line">          String tag = &quot;[Dump Stack]&quot;;</span><br><span class="line">          String msg = &quot;=====miniAppApi&quot; + String.valueOf(param.args[0]) + &quot;*******&quot;;</span><br><span class="line">          printLog(tag,msg);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>hook 到小程序 thread 的 handler post<br>原代码是 hook android.os.Handler.getPostMessage，可能是微信 apk 版本不同，7.0.20 中是通过 handler.post(runnable)，因此 hook 作者给出的 getPostMessage 拿不到任何调用信息，hook handler.post 方法有信息，并且检查调用栈可以找到上述 jsapi.d.a 方法。通过 hook 并进行调用栈筛选可以拿到 __实现小程序 API 的 runnable 实例__。</p>
</li>
<li><p>hook handler 的消息处理函数<br>作者 hook 的是 handleCallback，笔者认为应该是基于 handler.dispatchMessage 中下列代码的考虑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// dispatchMessage 内部</span><br><span class="line">if(message.callback)&#123;</span><br><span class="line">  handleCallback(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此作者的 hook 代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 作者 hook 并做了 message.what != 0 的过滤</span><br><span class="line">// hook android.os.Handler.handleCallback</span><br><span class="line">if(message.what == 0) return;</span><br></pre></td></tr></table></figure>
<p>但是这里 hook 不到任何东西，因为这里想 hook 的消息处理逻辑跟前面的 getPostMessage 是对应的，因为在那种情况下 message.what 是对应的处理线程 id，但是如果是用 handler.post 的话会直接回调运行 runnable.run 代码，因此 message.what 不是 threadId，而是 0（调度线程id），所以即使 hook 到也会被第二行 if(message.what == 0) 判断过滤掉，所以笔者修改 hook 函数为为 android.os.Handler.dispatchMessage，修改筛选条件为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// hook android.os.Handler.dispatchMessage</span><br><span class="line">if(message.callback == null)&#123;</span><br><span class="line">  return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>hook Android API<br>这个就不多说了，正常 hook 系统 API 并打印</p>
</li>
<li><p>Log 处理<br>Hook 到的以上信息都打印在 log 中，还需要后续追加对 log 处理，但是逻辑很简单，就是提取上述四个信息，构建（小程序 API thread —- runnable 实例 name —- 处理含 runnable 实例的 Handler thread —- 该 Handler Thread 的 Android API 调用），即可得到 __小程序 API  —- Android API Mapping__。</p>
</li>
</ol>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">package com.example.a91377.xpdemo;</span><br><span class="line"></span><br><span class="line">import android.app.Application;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.location.Location;</span><br><span class="line">import android.location.LocationManager;</span><br><span class="line">import android.net.wifi.WifiManager;</span><br><span class="line">import android.os.Message;</span><br><span class="line">import android.telephony.TelephonyManager;</span><br><span class="line">import android.util.Log;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Modifier;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">import de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line">import de.robv.android.xposed.XC_MethodHook;</span><br><span class="line">import de.robv.android.xposed.XC_MethodReplacement;</span><br><span class="line">import de.robv.android.xposed.XposedBridge;</span><br><span class="line">import de.robv.android.xposed.XposedHelpers;</span><br><span class="line">import de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line">import static de.robv.android.xposed.XposedHelpers.findClass;</span><br><span class="line"></span><br><span class="line">public class Xp_Demo implements IXposedHookLoadPackage &#123; //1.实现接口</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handleLoadPackage(XC_LoadPackage.LoadPackageParam lpparam) throws Throwable &#123; //1.实现接口方法</span><br><span class="line">        //com.example.a91377.myapplication;</span><br><span class="line">        //com.tencent.mm</span><br><span class="line">        if (lpparam.packageName.equals(&quot;com.tencent.mm&quot;)) //进入其他应用的进程 -参数：包名</span><br><span class="line">        &#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                XposedHelpers.findAndHookMethod(Application.class,</span><br><span class="line">                        &quot;attach&quot;,</span><br><span class="line">                        Context.class,</span><br><span class="line">                        new XC_MethodHook() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">                                super.afterHookedMethod(param);</span><br><span class="line">                                Context context = (Context)param.args[0];</span><br><span class="line">                                ClassLoader classLoader = context.getClassLoader();</span><br><span class="line">                                HookLocation(classLoader);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125;catch (Throwable e)&#123;</span><br><span class="line">                XposedBridge.log(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void HookLocation(ClassLoader classLoader) throws ClassNotFoundException&#123;</span><br><span class="line">        Class&lt;?&gt; runnable = findClass(&quot;java.lang.Runnable&quot;, classLoader);</span><br><span class="line">        // hook android.os.Handler.post</span><br><span class="line">        XposedHelpers.findAndHookMethod(</span><br><span class="line">                &quot;android.os.Handler&quot;, classLoader, &quot;post&quot;, runnable,</span><br><span class="line">                new XC_MethodHook() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void afterHookedMethod(MethodHookParam param)</span><br><span class="line">                            throws Throwable &#123;</span><br><span class="line">                        boolean flag2 = false;</span><br><span class="line">                        long threadId = 00000;</span><br><span class="line">                        for (Map.Entry&lt;Thread, StackTraceElement[]&gt; stackTrace : Thread.getAllStackTraces().entrySet()) &#123;</span><br><span class="line">                            Thread thread = (Thread) stackTrace.getKey();</span><br><span class="line">                            StackTraceElement[] stack = (StackTraceElement[]) stackTrace.getValue();</span><br><span class="line"></span><br><span class="line">                            // 进行过滤</span><br><span class="line">                            if (!thread.equals(Thread.currentThread())) &#123;</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            for (StackTraceElement stackTraceElement : stack) &#123;</span><br><span class="line">                                if (stackTraceElement.getClassName().equals(&quot;com.tencent.mm.plugin.appbrand.jsapi.d&quot;) &amp;&amp; stackTraceElement.getMethodName().equals(&quot;a&quot;)) &#123;</span><br><span class="line">                                    flag2 = true;</span><br><span class="line">                                    break;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (!flag2) &#123;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            threadId = thread.getId();</span><br><span class="line">                            Log.i(&quot;hookgetPostMessage&quot;, String.valueOf(param.args[0]) + &quot;********&quot; + thread.getName() + &quot;-------&quot; + thread.getId());</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                        if (flag2) &#123;</span><br><span class="line">                            Message m = (Message) param.getResult();</span><br><span class="line">                            m.what = (int) threadId;</span><br><span class="line">                            param.setResult(m);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        // hook android.os.Handler.dispatchMessage</span><br><span class="line">        Class&lt;?&gt; message = findClass(&quot;android.os.Message&quot;, classLoader);</span><br><span class="line">        XposedHelpers.findAndHookMethod(</span><br><span class="line">                &quot;android.os.Handler&quot;, classLoader, &quot;dispatchMessage&quot;, message,</span><br><span class="line">                new XC_MethodHook() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void afterHookedMethod(MethodHookParam param)</span><br><span class="line">                            throws Throwable &#123;</span><br><span class="line">                        Message m = (Message) param.args[0];</span><br><span class="line">                        Runnable r = m.getCallback();</span><br><span class="line">                        int relatedThreadId = m.what;</span><br><span class="line">                        if(r == null)&#123;</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                        String tag = &quot;=========handleCallback&quot;;</span><br><span class="line">                        String msg = &quot;runnable:  &quot; + String.valueOf(r) + &quot;********&quot; + &quot;relatedThreadid: &quot; + String.valueOf(relatedThreadId) + &quot;---&quot; + &quot;currentId: &quot;;</span><br><span class="line">                        printLog(tag,msg);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        // hook invokeHandler 打印出线程ID和第一个参数, 即小程序的api</span><br><span class="line">        XposedHelpers.findAndHookMethod(</span><br><span class="line">                //7.0.20 d 类的 y 方法</span><br><span class="line">                &quot;com.tencent.mm.plugin.appbrand.jsapi.d&quot;, classLoader, &quot;y&quot;, String.class, String.class, int.class, // 被Hook函数的名称</span><br><span class="line">                new XC_MethodHook() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void afterHookedMethod(MethodHookParam param)</span><br><span class="line">                            throws Throwable &#123;</span><br><span class="line">                        String tag = &quot;[Dump Stack]&quot;;</span><br><span class="line">                        String msg = &quot;=====miniAppApi&quot; + String.valueOf(param.args[0]) + &quot;*******&quot;;</span><br><span class="line">                        printLog(tag,msg);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //hook dangerous Android APi</span><br><span class="line">        String methodList[][] = com.example.a91377.xpdemo.Method.methodList;</span><br><span class="line">        for (int i = 0; i &lt; methodList.length; i++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = findClass(methodList[i][0], classLoader);</span><br><span class="line">            for (Method method : clazz.getDeclaredMethods()) &#123;</span><br><span class="line">                final String methodName = method.getName();</span><br><span class="line">                if (!methodName.equals(methodList[i][1])) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!Modifier.isAbstract(method.getModifiers())) &#123;</span><br><span class="line"></span><br><span class="line">                    XposedBridge.hookMethod(method, new XC_MethodHook() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        protected void afterHookedMethod(MethodHookParam param) throws Throwable &#123;</span><br><span class="line">                            String tag = &quot;[hookWifi]&quot;;</span><br><span class="line">                            String msg = &quot;****&quot; + methodName + &quot;threadId&quot;;</span><br><span class="line">                            printLog(tag,msg);</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void printLog(String tag, String msg) &#123;</span><br><span class="line">        for (Map.Entry&lt;Thread, StackTraceElement[]&gt; stackTrace : Thread.getAllStackTraces().entrySet()) &#123;</span><br><span class="line">            Thread thread = (Thread) stackTrace.getKey();</span><br><span class="line">            StackTraceElement[] stack = (StackTraceElement[]) stackTrace.getValue();</span><br><span class="line">            // 进行过滤</span><br><span class="line">            if (!thread.equals(Thread.currentThread())) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String threadName = thread.getName();</span><br><span class="line">            long threadId = thread.getId();</span><br><span class="line">            Log.d(tag, msg + threadId);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // IXposedHookLoadPackage.java</span><br><span class="line">    // 1. handleLoadPackage, 这个方法用于在加载应用程序包的时候执行用户操作</span><br><span class="line">    // 2. final LoadPackageParam lpparam 这个参数包含了加载应用程序的基本信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // XposedHelpers.java</span><br><span class="line">    //findAndHookMethod 是一个辅助方法，可以静态导入使用</span><br><span class="line">    //参数： 1. 需要hook住的类名 2. 需要hook住的方法名 3.回调函数，参数集包含了（1. hook的目标方法的参数， 2 回调方法）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //XposedBridge.java</span><br><span class="line">    // 1. 无参方法：log 该方法可以将log信息以及Throwable 抛出的异常信息输出到标准的logcat以及/data/Xposed/debug.log这个文件中</span><br><span class="line">    // 2. 无参方法 hookAllMethods/hookAllConstructors 该方法可以用来hook住某个类中所有方法或者构造函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/15/apinath/" data-id="cl1zs4wvr0000lgwx3s1u5xip" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-miniscrawler" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/31/miniscrawler/" class="article-date">
  <time datetime="2022-03-31T12:03:23.000Z" itemprop="datePublished">2022-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/31/miniscrawler/">【技术】【小程序】MiniScrawler 工具原理解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前用到了文章<a target="_blank" rel="noopener" href="https://web.cse.ohio-state.edu/~lin.3021/file/SIGMETRICS21.pdf">A Measurement Study of Wechat Mini-Apps</a>提出的微信小程序半自动化收集工具<a target="_blank" rel="noopener" href="https://github.com/OSUSecLab/MiniCrawler">MiniCrawler</a>。最近深入看一下工具实现细节。</p>
<h1 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h1><p>工具有两个功能，一是小程序元数据收集，另一个是小程序包下载。</p>
<h2 id="小程序元数据收集"><a href="#小程序元数据收集" class="headerlink" title="小程序元数据收集"></a>小程序元数据收集</h2><p>具体原理不难，就是拿到用户的请求参数，然后替换 request 中的 keyword 字段，批量发起请求。</p>
<ul>
<li>用户手动在小程序搜索页面输入关键词，工具会帮助拿到用户向服务七搜索请求的一些参数，主要是认证参数</li>
<li>用户把这些参数和待搜索词列表放在指定位置</li>
<li>工具即可用这些拿到的参数批量发起小程序搜索请求，拿到服务器返回的多个小程序的元数据（小程序名、小程序 AppId 等）</li>
</ul>
<h2 id="小程序包下载"><a href="#小程序包下载" class="headerlink" title="小程序包下载"></a>小程序包下载</h2><p><strong>要求</strong></p>
<ol>
<li>微信 App 得是 7.0.20 版本</li>
<li>编译并安装 XposedPlugin</li>
<li>打开任意小程序页面</li>
<li>运行 <code>adb shell am broadcast -a android.intent.myper --es appid &quot;&#123;待下载小程序的appid&#125;&quot;</code>，工具会自动下载链接及相关信息到 /sdcard/apps.txt</li>
</ol>
<h3 id="逆向-XposedPlugin"><a href="#逆向-XposedPlugin" class="headerlink" title="逆向 XposedPlugin"></a>逆向 XposedPlugin</h3><p>看了 XposedPlugin 源码，注册了个 <code>android.intent.myper</code> 的 receiver 用来接收待下载小程序的 appid。</p>
<p>Q：具体如何起到启动目标小程序的作用？<br>A：<code>com.example.vsa.xposedutility.tests.WechatMiniAppsDownloader</code> 中，工具接了 appid 之后 invoke 了小程序 API（代码如下）。通过调起 <code>wx.navigateToMiniProgram</code>，appid 作为参数传进去，达到从当前小程序（任意的，但需要是小程序的 context）跳转到目标小程序的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = next.getClass().getMethod(&quot;invokeHandler&quot;, String.class, String.class, Integer.TYPE);</span><br><span class="line">method.invoke(next, &quot;navigateToMiniProgram&quot;, &quot;&#123;\&quot;appId\&quot;:\&quot;&quot; + stringExtra + &quot;\&quot;,\&quot;extraData\&quot;:\&quot;\&quot;,\&quot;envVersion\&quot;:\&quot;release\&quot;,\&quot;scene\&quot;:1037,\&quot;sceneNote\&quot;:\&quot;\&quot;&#125;&quot;, 9999);</span><br></pre></td></tr></table></figure>

<p>Q：如何拿到下载链接及包的相关信息？<br>A：<code>com.example.vsa.xposedutility.tests.Wechat7020</code> 类中 <code>hookAll</code> 中可以看出（如下图），关注的是微信 App 里的两个类：<code>com.tencent.mm.plugin.appbrand.appcache.ba</code>、<code>com.tencent.mm.plugin.appbrand.jsapi.l</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void beforeHookedMethod(XC_MethodHook.MethodHookParam methodHookParam) throws Throwable &#123;</span><br><span class="line">    Log.d(Wechat7020.TAG, &quot;----&gt;&gt;&gt;:&quot; + methodHookParam.method.getName());</span><br><span class="line">    Utilities.printParameter(Wechat7020.TAG, methodHookParam);</span><br><span class="line">    if (methodHookParam.method.getName().equals(&quot;invokeHandler&quot;) &amp;&amp; !Wechat7020.did) &#123;</span><br><span class="line">        Wechat7020.did = true;</span><br><span class="line">        methodHookParam.thisObject.getClass().getMethod(&quot;invokeHandler&quot;, String.class, String.class, Integer.TYPE);</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodHookParam.method.getDeclaringClass().getName().equals(&quot;com.tencent.mm.plugin.appbrand.appcache.ba&quot;) &amp;&amp; (methodHookParam.method instanceof Constructor) &amp;&amp; ((Constructor) methodHookParam.method).getParameterTypes().length == 4) &#123;</span><br><span class="line">        Utilities.writeToFile(&quot;/sdcard/apps.txt&quot;, (methodHookParam.args[0] + BuildConfig.FLAVOR) + &quot; &quot; + (methodHookParam.args[2] + BuildConfig.FLAVOR) + &quot; &quot; + (methodHookParam.args[3] + BuildConfig.FLAVOR) + &quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (methodHookParam.method.getDeclaringClass().getName().equals(&quot;com.tencent.mm.plugin.appbrand.jsapi.l&quot;) &amp;&amp; !WechatMiniAppsDownloader.wvs.contains(methodHookParam.thisObject)) &#123;</span><br><span class="line">        WechatMiniAppsDownloader.wvs.add(methodHookParam.thisObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="逆向微信"><a href="#逆向微信" class="headerlink" title="逆向微信"></a>逆向微信</h3><p><strong>com.tencent.mm.plugin.appbrand.appcache.ba</strong><br>根据 XposedPlugin 代码行为，应该在 hook 到该类之后写数据（包下载 url）到 <code>/sdcard/apps.txt</code>，但实测后没有该文件。只有在初始，需要下载微信小程序 jssdk 包的时候会调用一下，但下载普通小程序根本不走这。<br>自己又静态分析了一阵，找到了 <code>com.tencent.mm.plugin.appbrand.appcache.bt.a(str,...)</code> 方法，参数 str 就是下载链接。不知道为什么在我这边是 <code>.bt</code> 类，而作者那边是 <code>.ba</code> 类，apk 版本是一样的。</p>
<p><strong>com.tencent.mm.plugin.appbrand.jsapi.l</strong><br>里面 <code>invokeHandler</code> 是调起小程序 api 的方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final String invokeHandler(String str, String str2, int i)</span><br></pre></td></tr></table></figure>

<p>里面 str 就是 invoke 的小程序方法名，本场景下是 <code>navigateToMiniProgram</code>，str2 是传给这个小程序方法的参数，本场景下是 JSON，包括 appId 等信息。<br>函数体内有一句<code>String y = dVar.y(str, str2, i);</code>，这里 trace 到后面是一个抽象类，该抽象类由多个子类实现。这些子类与 <code>wx.&#123;subAPI&#125;</code> 一一对应。<code>navigateToMiniprogram</code> 是 <code>com.tencent.mm.plugin.appbrand.jsapi.miniprogram_navigator.g</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/31/miniscrawler/" data-id="cl1ezf4650000fcwx5y0h8eyw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-esprimae" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/24/esprimae/" class="article-date">
  <time datetime="2022-03-24T13:07:25.000Z" itemprop="datePublished">2022-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/24/esprimae/">【技术】【JS 静态分析】Javascript 分析工具 Esprima</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前分析 JS 用到的工具，用于生成 JS 的 AST，马克一下工具用法。</p>
<h1 id="Esprima"><a href="#Esprima" class="headerlink" title="Esprima"></a>Esprima</h1><p>官网：<a target="_blank" rel="noopener" href="https://docs.esprima.org/en/stable/getting-started.html">https://docs.esprima.org/en/stable/getting-started.html</a><br>体验网址：<a target="_blank" rel="noopener" href="https://esprima.org/demo/parse.html#">https://esprima.org/demo/parse.html#</a><br>参考资料：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/47d9b2a365c5">https://www.jianshu.com/p/47d9b2a365c5</a></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>是一个用于对 JS 代码做词法或者语法分析的工具，只支持js，不支持 flow 或者 typescript 格式。语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">esprima.parseScript(input, config, delegate)</span><br><span class="line">esprima.parseModule(input, config, delegate)</span><br></pre></td></tr></table></figure>

<p>input 代表原始 js 字符串；config 是如下的配置对象：<br><img src="/pics/esprima/image.png" alt="配置对象"></p>
<h2 id="语法树解析"><a href="#语法树解析" class="headerlink" title="语法树解析"></a>语法树解析</h2><ul>
<li>语法树的总体结构就两种<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Program &#123;</span><br><span class="line">  type: &#x27;Program&#x27;;</span><br><span class="line">  sourceType: &#x27;script&#x27;;</span><br><span class="line">  body: StatementListItem[];</span><br><span class="line">&#125;</span><br><span class="line">interface Program &#123;</span><br><span class="line">  type: &#x27;Program&#x27;;</span><br><span class="line">  sourceType: &#x27;module&#x27;;</span><br><span class="line">  body: ModuleItem[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 变量声明及执行语句</span><br><span class="line">type StatementListItem = Declaration | Statement;</span><br><span class="line">// 变量声明、执行语句、导入导出模块</span><br><span class="line">type ModuleItem = ImportDeclaration | ExportDeclaration | StatementListItem;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>_<strong>Declaration</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Declaration = ClassDeclaration | FunctionDeclaration |  VariableDeclaration;</span><br></pre></td></tr></table></figure>

<p>_<strong>Statement</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type Statement = BlockStatement | BreakStatement | ContinueStatement |</span><br><span class="line">    DebuggerStatement | DoWhileStatement | EmptyStatement |</span><br><span class="line">    ExpressionStatement | ForStatement | ForInStatement |</span><br><span class="line">    ForOfStatement | FunctionDeclaration | IfStatement |</span><br><span class="line">    LabeledStatement | ReturnStatement | SwitchStatement |</span><br><span class="line">    ThrowStatement | TryStatement | VariableDeclaration |</span><br><span class="line">    WhileStatement | WithStatement;</span><br></pre></td></tr></table></figure>

<p>_<strong>其中 ExpressionStatement</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface ExpressionStatement &#123;</span><br><span class="line">    type: &#x27;ExpressionStatement&#x27;;</span><br><span class="line">    expression: Expression;</span><br><span class="line">    directive?: string;</span><br><span class="line">&#125;</span><br><span class="line">// Expression 类型</span><br><span class="line">type Expression = ThisExpression | Identifier | Literal |</span><br><span class="line">    ArrayExpression | ObjectExpression | FunctionExpression | ArrowFunctionExpression | ClassExpression |</span><br><span class="line">    TaggedTemplateExpression | MemberExpression | Super | MetaProperty |</span><br><span class="line">    NewExpression | CallExpression | UpdateExpression | AwaitExpression | UnaryExpression |</span><br><span class="line">    BinaryExpression | LogicalExpression | ConditionalExpression |</span><br><span class="line">    YieldExpression | AssignmentExpression | SequenceExpression;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/24/esprimae/" data-id="cl150p0p800008gwxap6v9pmu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Xposed" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/17/Xposed/" class="article-date">
  <time datetime="2022-03-17T07:50:27.000Z" itemprop="datePublished">2022-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/17/Xposed/">【BUG 体质康复日记】尝试在 Android 10 安装 Xposed 踩的坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="由于需要在新测试机（Android-10）上使用-Xposed，记录一下踩坑心得（苦涩-jpg"><a href="#由于需要在新测试机（Android-10）上使用-Xposed，记录一下踩坑心得（苦涩-jpg" class="headerlink" title="由于需要在新测试机（Android 10）上使用 Xposed，记录一下踩坑心得（苦涩.jpg)"></a>由于需要在新测试机（Android 10）上使用 Xposed，记录一下踩坑心得（苦涩.jpg)</h1><h1 id="踩到的坑"><a href="#踩到的坑" class="headerlink" title="踩到的坑"></a>踩到的坑</h1><h2 id="Xposed-报错“下载-http-dl-xposed-info-repo-full-xml-gz-失败”"><a href="#Xposed-报错“下载-http-dl-xposed-info-repo-full-xml-gz-失败”" class="headerlink" title="Xposed 报错“下载 http://dl.xposed.info/repo/full.xml.gz 失败”"></a>Xposed 报错“下载 <a target="_blank" rel="noopener" href="http://dl.xposed.info/repo/full.xml.gz">http://dl.xposed.info/repo/full.xml.gz</a> 失败”</h2><p>错误原因：用了 http 协议，应该是 https 协议<br>解决方法：改 apk 包，对应字段的 http 改成 https 就好（苦涩.jpg)</p>
<h2 id="框架无响应"><a href="#框架无响应" class="headerlink" title="框架无响应"></a>框架无响应</h2><p>无报错，并且安装成功后，Xposed 无法正常使用，表现为操作无响应<br>原因应该是 Xposed 框架很久不更新了，无法兼容较新的系统版本。</p>
<h2 id="Android-10-上-Xposed-的正确打开方式"><a href="#Android-10-上-Xposed-的正确打开方式" class="headerlink" title="Android 10 上 Xposed 的正确打开方式"></a>Android 10 上 Xposed 的正确打开方式</h2><p>最终为了快速解决问题上手干活用了 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/348857520">LSposed</a></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="Android-Zygote进程"><a href="#Android-Zygote进程" class="headerlink" title="Android Zygote进程"></a>Android Zygote进程</h2><p>Zygote 进程是 Android 系统第一个拥有 Java 运行环境的进程，由用户空间第一个进程 init 进程通过 init.rc 文件创建，从 init 进程（pid 为 1） fork 而来。所有 APP 进程都是由 Zygote fork 出来，Zygote 进程在启动过程将创建 Java ART 虚拟机，预加载一个 Java 进程需要的所有资源，子进程被创建后就可以直接使用这些资源。</p>
<h2 id="Xposed-原理"><a href="#Xposed-原理" class="headerlink" title="Xposed 原理"></a>Xposed 原理</h2><p>Xposed 会替换 Zygote 进程达到控制所有 APP 进程的目的。<br>Xposed 通过修改 ART/Dalvik 虚拟机，注册需要 hook 的函数为 Native 函数，这样执行到相应函数时，虚拟机优先执行 Narive 函数，然后执行 Java 函数。</p>
<h3 id="基于-Dalvik-的-Hook"><a href="#基于-Dalvik-的-Hook" class="headerlink" title="基于 Dalvik 的 Hook"></a>基于 Dalvik 的 Hook</h3><p>将被 Hook 方法修改为一个 JNI 方法，然后绑定一个 Xposed 自定义处理方法逻辑的函数上。</p>
<p>被 Hook 方法调用过程</p>
<ul>
<li>Dalvik 将会进行代码的解释执行，Java 方法进入 Dalvik 虚拟机中会被转化为一个 Method 对象</li>
<li>虚拟机判断这个方法如果是一个 JNI 方法，就会直接调用它绑定的的 nativeFunc 函数</li>
<li>来到 Xposed 处理 Hook 的函数中，这个函数将这个被 Hook 方法的参数进行转发，让 Xposed 模块提供的处理 Hook 的回调方法来接管原来的逻辑，获得新的返回值返回给被 Hook 方法，即可完成整个 Hook 操作</li>
</ul>
<h3 id="基于-ART-的-Hook"><a href="#基于-ART-的-Hook" class="headerlink" title="基于 ART 的 Hook"></a>基于 ART 的 Hook</h3><p>需要重新修改编译 ART 虚拟机的源码，重新编译出 ART 虚拟机的可执行文件 libart.so，替换 Android 系统中的 ART 虚拟机。核心原理就是直接修改一个方法对应的汇编代码的地址，让方法直接跳转到指定地址执行，然后就可以执行自定义的逻辑进行 Hook 处理。</p>
<p>被 Hook 方法调用过程</p>
<ul>
<li>ART 对方法代码进行执行，首先这个 Java 方法在 ART 虚拟机中将使用一个 ArtMethod 对象表示</li>
<li>进入 ART 的 Java 方法执行函数中，会跳入一段蹦床代码中进行执行，这段蹦床代码又会跳入这个 ArtMethod 对象设置的汇编代码地址处</li>
<li>进而执行到 Xposed 用于处理 Hook 的代码中，之后完成 Hook 逻辑</li>
</ul>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6b4a80654d4e">https://www.jianshu.com/p/6b4a80654d4e</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47883636/article/details/109018440">https://blog.csdn.net/weixin_47883636/article/details/109018440</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/17/Xposed/" data-id="cl0uz4nbu00001gwx3rsf6k8p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/BUG%E5%8F%8D%E6%80%9D/" rel="tag">BUG反思</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-paperCCS20" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/11/paperCCS20/" class="article-date">
  <time datetime="2022-03-11T06:06:32.000Z" itemprop="datePublished">2022-03-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/11/paperCCS20/">【paper summary】Demystifying Resource Management Risks in Emerging Mobile App-in-App Ecosystems</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="梳理小程序相关工作中碰到的比较有价值的一篇文章，整理并总结一下。"><a href="#梳理小程序相关工作中碰到的比较有价值的一篇文章，整理并总结一下。" class="headerlink" title="梳理小程序相关工作中碰到的比较有价值的一篇文章，整理并总结一下。"></a>梳理小程序相关工作中碰到的比较有价值的一篇文章，整理并总结一下。</h1><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><ul>
<li>Demystifying Resource Management Risks in Emerging Mobile App-in-App Ecosystems</li>
<li>link：<a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/3372297.3417255">https://dl.acm.org/doi/pdf/10.1145/3372297.3417255</a></li>
<li>publish：CCS 20</li>
</ul>
<h2 id="文章内容"><a href="#文章内容" class="headerlink" title="文章内容"></a>文章内容</h2><ol>
<li><p>研究什么？<br>作者分析小程序框架安全，提出三类小程序生态系统中，由于资源管理不完善引起的<strong>三类漏洞</strong>。对三类漏洞进行<strong>阐述、攻击验证、提出检测方法及缓解措施</strong>。</p>
</li>
<li><p>作者贡献？</p>
</li>
</ol>
<ul>
<li>提出现有 app-in-app 生态系统中资源管理方式存在的安全性问题。提出三种攻击方式，并简单验证。<strong>个人认为三种攻击影响确实蛮大的</strong>，后面具体介绍。</li>
<li>对自己发现的问题进行一个 measurement study，其中借助了自己开发的自动化检测工具，叫 apinat。个人认为这个工具贡献技术上贡献不太强，主要为检测两类漏洞辅助。（<strong>为什么是检测两类漏洞，不是检测三类漏洞，因为第三个漏洞确实不需要特别检测，后续具体介绍。</strong>）</li>
<li>总结一些经验教训与问题相应的缓解措施.</li>
</ul>
<h1 id="三类漏洞"><a href="#三类漏洞" class="headerlink" title="三类漏洞"></a>三类漏洞</h1><h2 id="敏感信息泄露"><a href="#敏感信息泄露" class="headerlink" title="敏感信息泄露"></a>敏感信息泄露</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><strong>本质就是不一致问题。</strong><br>小程序宿主 APP 对小程序 API 有权限管理，系统对系统 API 有权限管理，同时小程序 API 本质还是在 APP Native 层开发，必然涉及到一些系统 API。<br>因此小程序 API 实际由一批系统 API 实现，因此可以通过这些系统 API 映射到系统权限，即可以通过映射获取<strong>小程序 API 对应哪些系统权限</strong>，同时平台又对小程序开发者要求<strong>小程序 API 应当与何权限映射</strong>，此时存在两种映射关系，这两种映射的<strong>不一致</strong>将导致敏感资源泄露的问题。<br>如果一个小程序 API 没有被小程序平台严格约束，但底层实现的代码调用了涉及敏感资源的 API，则该小程序 API 将造成敏感资源泄露。作者将之命名为 Encapsulated API。</p>
<h3 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h3><ol>
<li>关注没有被小程序平台列为涉及敏感资源的小程序 API</li>
<li>构造（小程序 API - 系统 APIs - 系统权限）这样一种映射</li>
<li>若某 API 映射的系统权限敏感，则检测到</li>
</ol>
<p>Q：作者如何构造这样一种映射？<br>A：</p>
<ol>
<li>使用 funfuzz 工具 invoke 几乎每一个小程序 API，如 invoke 失败则手动构造 input。由此得到<strong>小程序 API - 系统 APIs 的映射</strong></li>
<li>由于作者认为，现有的系统 API 到系统权限的映射不够精确，因此作者选择人工构造 <strong>系统 API - 系统权限的映射</strong>。</li>
<li>由此得到完整的（小程序 API - 系统 APIs - 系统权限）映射</li>
</ol>
<h2 id="窗口欺骗"><a href="#窗口欺骗" class="headerlink" title="窗口欺骗"></a>窗口欺骗</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><strong>类似钓鱼</strong>。针对 web app 这类平台（safari、chrome 等），存在伪造登录页面的机会；针对微信、支付宝这类平台，伪造小程序付款页面。</p>
<h3 id="检测方法-1"><a href="#检测方法-1" class="headerlink" title="检测方法"></a>检测方法</h3><ol>
<li>仍然借助 funfuzz 将每个小程序 API invoke 一遍</li>
<li>对比调用 API 前后的截图内容，识别是否存在<strong>敏感字段</strong>，从而判断是否存在窗口欺骗的潜在风险。</li>
</ol>
<p>Q：敏感字段哪里来？如何定义？<br>A：参考前人工作 <a target="_blank" rel="noopener" href="https://cs.uwaterloo.ca/~yaafer/teaching/papers/nan2018ndss.pdf">NDSS18</a> 提供的敏感字段列表</p>
<h2 id="小程序伪装"><a href="#小程序伪装" class="headerlink" title="小程序伪装"></a>小程序伪装</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>仅针对安卓系统，因为 iOS 系统对小程序的页面管理略不同。具体来说，iOS 系统不会在“最近使用”页面显示单个小程序，而安卓系统会将小程序与 APP 并列显示，这就为攻击者提供伪造小程序的机会。<br>作者观察到一个事实，每个小程序平台 APP 都有一个<strong>magic number</strong>，用于管理显示小程序数量。一旦打开的小程序数量超过这个数字，APP 将在后台静默关闭第一个打开的小程序。由于用户并不知道这样一个事实，因此在 APP 静默关闭第一个小程序后，攻击者可以通过伪造 UI 装作是第一个小程序仍然打开，欺骗用户进行敏感操作。</p>
<h3 id="检测方法-2"><a href="#检测方法-2" class="headerlink" title="检测方法"></a>检测方法</h3><p>由于 magic number 及每个 APP 会静默关闭第一个小程序这个事实确然存在，因此无需检测，这些平台 APP 都存在被攻击者使用 UI 欺骗窃取用户敏感信息的风险。</p>
<h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>这篇文章第一个研究小程序框架安全，研究对象涵盖海内外各大 Super APP。作者验证了三类漏洞确实存在，且对小程序用户影响深远，研究意义重大。<br>在技术方面，作者没有突出的贡献，但是设计的 Apinat 能够检测上述漏洞，且作者开源了一些对后续工作有帮助的资源或代码参考，还是为小程序安全研究做了很大贡献的。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/11/paperCCS20/" data-id="cl0m0x4vi0000g8wx6asj1e7h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paperSummary/" rel="tag">paperSummary</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-wechat-mini-program-unpack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/03/03/wechat-mini-program-unpack/" class="article-date">
  <time datetime="2022-03-03T10:28:18.000Z" itemprop="datePublished">2022-03-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/03/03/wechat-mini-program-unpack/">【技术】【小程序】微信小程序解包工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>接上次小程序的基础知识，分享一个小程序解包工具<a target="_blank" rel="noopener" href="https://github.com/xuedingmiaojun/wxappUnpacker">wxunpacker</a>（base64 解码跳转新链接）。</p>
<h1 id="小程序包结构"><a href="#小程序包结构" class="headerlink" title="小程序包结构"></a>小程序包结构</h1><p><a target="_blank" rel="noopener" href="https://jwy630.github.io/2022/02/19/test/">上篇文章</a>提到过，小程序的 wxapkg 文件实际上是个二进制文件，没有加密等复杂操作。<br>其结构可以分为三个部分，header、index 及 data。</p>
<h2 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h2><ul>
<li>8 位：firstMark，总为 190（0xbe）</li>
<li>32 位：未知含义，目前来看总为 0</li>
<li>32 位：Index 段长度</li>
<li>32 位：Data 段长度</li>
<li>8 位：lastMark，总为 237（0xed）</li>
<li>32 位：文件数目，<strong>fileCount</strong></li>
</ul>
<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>单个文件的字段如下，一个 wxapkg 中有 <strong>fileCount</strong> 个这样的字段</p>
<ul>
<li>32 位：文件名长度 nameLength</li>
<li>长度为 nameLength 的文件名</li>
<li>32 位：offset，文件在数据段中的位置</li>
<li>32 位：文件大小</li>
</ul>
<h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><p>所有的文件数据，上述 index 中的 offset 从中索引</p>
<h1 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h1><h2 id="环境与工具"><a href="#环境与工具" class="headerlink" title="环境与工具"></a>环境与工具</h2><ol>
<li>node</li>
<li>前面提到的微信 unpacker</li>
</ol>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol>
<li><p>区分主包与子包<br>子包解包后得到的文件内容与主包差别较大，缺少几个主要文件：app-service.js、app.json、app-config.json 等，是关于整个包的配置。因此如果直接使用解主包的指令解子包，工具将报错（虽然目录下的内容仍然可以获得）。</p>
</li>
<li><p>解主包<br>{main_package.wxapkg} 直接执行下面指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node wuWxapkg.js main_package.wxapkg</span><br></pre></td></tr></table></figure></li>
<li><p>解子包<br>{sub_package.wxapkg} 执行下面指令，其中 -s 用于指示主包的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node wuWxapkg.js sub_package.wxapkg -s=main_package</span><br></pre></td></tr></table></figure></li>
</ol>
<p>解包后就可以得到源代码，解包后的文件结构及不同文件作用见<a target="_blank" rel="noopener" href="https://jwy630.github.io/2022/02/19/test/">前文</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/03/wechat-mini-program-unpack/" data-id="cl0avti9f0000x0wx2r2s7eon" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-summary-flash-boy-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/24/summary-flash-boy-2/" class="article-date">
  <time datetime="2022-02-24T10:45:43.000Z" itemprop="datePublished">2022-02-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/24/summary-flash-boy-2/">【paper summary】 Flash Boys 2.0:Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><h2 id="文章信息"><a href="#文章信息" class="headerlink" title="文章信息"></a>文章信息</h2><p>-Flash Boys 2.0:Frontrunning, Transaction Reordering, and Consensus Instability in Decentralized Exchanges<br>-link: <a target="_blank" rel="noopener" href="https://pdaian.com/flashboys2.pdf">https://pdaian.com/flashboys2.pdf</a><br>-publish: Security 20</p>
<h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><p>该工作解释了 DEX 设计缺陷威胁到底层区块链安全。通过研究一个利用 DEX 漏洞出现的套利机器人社区。研究结果表明，这些机器人表现出许多类似的市场开发行为——抢先交易、积极的延迟优化等。<br>该工作探索了催生套利机器人的 DEX 设计缺陷，衡量和建模这些机器人的行为，并阐明发现中暗示的系统性智能合约生态系统风险。</p>
<h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><ul>
<li>报道了一个相当大的机器人经济体，他们从 DEX 中的交易排序提供的机会中获利。作者量化了特定套利子集的广度，纯粹收入机会，为订单操纵的盈利能力提供了下限。</li>
<li>正式模拟了机器人在优先 gas 拍卖中相互竞争矿工提供的交易优先级的行为。实证研究验证了模型的几个关键预测，包括机器人在一种盈利合作形式上的融合，这种合作形式涉及最小的 gas 价格上涨。文章还表明，在许多具体案例中，仅来自纯收入套利的机器人收入就远远超过了以太坊的区块奖励和交易费用。</li>
<li>最后，作者认为矿工可提取的价值，特别是订单优化费用，修改交易订单的隐性费用，威胁到区块链共识的稳定性。此类费用足以补贴对网络的严重攻击。它们构成了一种经济脆弱性，应该是以太坊当前关注的一个原因。</li>
</ul>
<h2 id="前人工作的不足"><a href="#前人工作的不足" class="headerlink" title="前人工作的不足"></a>前人工作的不足</h2><p>其他工作集中在围绕智能合约前端运行的知识系统化，包括引用这项工作的早期公开版本，但尚未衡量该经济体的规模，或把它与协议攻击的联系正式化。</p>
<h1 id="1-Background"><a href="#1-Background" class="headerlink" title="1. Background"></a>1. Background</h1><h2 id="pure-revenue-opportunities"><a href="#pure-revenue-opportunities" class="headerlink" title="pure revenue opportunities"></a>pure revenue opportunities</h2><p>场景：在智能合约系统中<br>成员：正常人 Alice，恶意 bot Bob<br>若 Alice 订单簿信息填写错误，如市场价 1 ETH 就可以买到 1 Token，但 Alice 的订单簿错写为“Buy 1 Token for 10 ETH”，此刻 Alice 可以发起取消交易。但 Bob 也可以发起交易 take 这次“不合理”的交易，只需增加 Gas 费用，使矿工在排序时将自己的交易排在 Alice 的 cancel 交易之前（即 frontrun），Bob 就可以以高于市场的价格卖出自己的 Token，净赚 9 ETH。过程如下图</p>
<p><img src="/pics/flashboy2/1.png" alt="pure revenue opportunities"></p>
<p>这样的套利机会被作者成为 pure revenue opportunities，纯粹收入机会。然而作者研究的场景是，在两个 bot 都发现粗心的 Alice 的订单簿后，为套利而互相竞价，如下图所示，两个套利机器人依靠不断增多自己的 Gas 价格与对方竞争，目的就是让矿工排序时，自己的交易排在对方前面，从而套取 Alice 损失的利益。这一过程被作者成为 PGA（Priority Gas Auction）。</p>
<p><img src="/pics/flashboy2/2.png" alt="2 bots competing for pure revenue opportunities"></p>
<h1 id="2-INTRO"><a href="#2-INTRO" class="headerlink" title="2. INTRO"></a>2. INTRO</h1><h2 id="作者关注的五个研究点"><a href="#作者关注的五个研究点" class="headerlink" title="作者关注的五个研究点"></a>作者关注的五个研究点</h2><p><strong>作者的关注点可以分为两类，一是应用层的纯粹收入机会，以及 bot 间为了纯粹收入而竞争的 PGA。另一类是区块链底层，矿工利用信息差可以获取的矿工可提取价值 MEV（Miner-Extractable Value），为了获取这种可提取价值，本文描述了两类攻击方法，分别是基于费用的分叉攻击，以及时间强盗攻击。</strong></p>
<ul>
<li>Pure revenue opportunities 纯粹收入机会：DEX 套利的一个特定子类别，代表更广泛的活动，这些是区块链交易，通过智能合约自动发布多笔交易，并在每笔交易资产中无条件获利。作者选择这些机会作为重点，因为它们的简单性使它们特别适合研究和测量。本文通过实验确定了迄今为止该经济体超过 600 万美元的下限，并描述了其参与的交易所和机器人。</li>
<li>优先GAS拍卖 (PGA，Priority Gas Auctions)：由于纯粹的收入机会提供无条件的收入，套利机器人经常通过竞标交易费用 (gas) 来相互竞争。作者正式对机器人 PGA 行为建模并观察合作平衡。</li>
<li>矿工可提取价值（MEV，Miner-Extractable Value）：矿工可直接从智能合约中提取的价值，作为加密货币的利润。 MEV 的一个特殊来源是排序优化 (ordering optimization，OO) 费用，这是由于矿工控制特定时期内的交易排序而产生的。PGA 和纯收入机会提供了一种 OO 费用来源。研究表明 MEV 会产生系统性共识层漏洞。</li>
<li>基于费用的分叉攻击 Fee-based Forking Attacks：本文表明，OO 费用可以激励矿工进行分叉攻击。虽然之前在比特币中对基于费用的攻击进行了理论上的研究，但本文凭经验证明了以太坊中当前的现实威胁。</li>
<li>时间强盗攻击 Time-bandit Attacks：本文表明，高 MEV 机制通常会导致一种新的攻击，在这种攻击中，矿工重写区块链历史以窃取过去智能合约分配的资金。作者称这些时间为时间强盗攻击。实验表明，来自纯收入利润和 PGA 机器人费用的 MEV 足以实现对当今以太坊的时间强盗攻击。</li>
</ul>
<h2 id="两个关键原因"><a href="#两个关键原因" class="headerlink" title="两个关键原因"></a>两个关键原因</h2><p><strong>作者声明自己的发现惊人主要有两个关键原因,本人理解的是,作者从 high-level 的两点阐述本安全威胁实际影响了从应用层到共识层这样一个事实（作者也在文章中反复强调这是文章的贡献之一）背后他认为的两点原因，第一点是底层安全模型差异，第二点是协议细节。具体来说就是</strong></p>
<ul>
<li>作者发现对比比特币这样的支付系统和以太坊这样的智能合约系统，其共识层安全模型是不同的，由于这样的差异，即比特币这样的支付系统执行原子操作，而以太坊的智能合约系统存在非原子性，所以会有这种攻击出现。</li>
<li>作者的分析结果还让作者有另一点重要发现，就是协议细节可以直接影响应用层安全性和智能合约为用户提供的公平性。通常智能合约安全性仅在应用层进行研究，抽象出矿工选择和 P2P中继器行为等低级细节，使理论研究易于处理。但是这样简单地抽象反而忽略了一个问题，就是低级协议行为也对智能合约构成根本挑战。</li>
</ul>
<h1 id="3-Measurement-Study"><a href="#3-Measurement-Study" class="headerlink" title="3. Measurement Study"></a>3. Measurement Study</h1><h2 id="实验设置"><a href="#实验设置" class="headerlink" title="实验设置"></a>实验设置</h2><p>由于现有工具没有能分析未确认和被拒绝的交易，作者编写了自己的工具，fork 了 GoEthereum 客户端，在内存池中记录未确认的交易。在多个数据中心部署了六个地理分布式节点，时间戳通过 NTP 同步到纳秒级。每次 ≈ 256 个节点中的一个与部署的修改节点之一对等时，都会收集一个观察结果，将事务转发给。作者共收集了 9 个月的数据，总计超过 300 GB，其中包括对 PGA 套利机器人的 708,385,840 次独特观察。节点位置如下图所示。</p>
<p><img src="/pics/flashboy2/3.png" alt="节点部署"></p>
<p>因为存储每笔以太坊交易的观察结果在技术上是不可行的，所以作者专注于可疑套利机器人交易的列表。该列表以观察到的在区块链上执行纯收入交易的账户为种子，并在任何时候以高于当前 gas 市场价格的数量级看到高价值 gas 替代交易时动态更新。</p>
<p>收集到数据后，作者开发了一套Python脚本来组合和分析这些数据。使用启发式方法（没有细说）将所有观察放到一个时间轴上，在发生高值 gas 替换事务时标识PGA。在此观察的时间间隔内的所有交易都被视为“拍卖”的一部分，分解为每个 bot 的行为。这些脚本还会对观察到的机器人的PGA、计算策略和延迟趋势进行统计。</p>
<h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><p>作者认为，实验设置仍然存在以下缺陷，理论上都会导致收集到的数据不完备，所以作者反复声明，该文章的发现仅作为现实世界中实际情况的下限参考。</p>
<ul>
<li>交易可能在到达节点之前被替换。尽管作者实际观察来看似乎不太可能，因为观察到的每个交易往往有数百个相关的 observation。</li>
<li>用于识别 PGA 的时间切片方法可能会将不相关的机器人活动集中到一个单一的“拍卖”中。（作者人工检查表明，由于拍卖相对不频繁，每隔几个小时进行一次，因此大部分拍卖由相关的机器人活动组成。）</li>
<li>时间切片还可以从其他非 PGA 行为的套利机器人中获取不相关的交易。作者通过仅包含在观察到的 PGA 中放置至少 4 个“出价”的机器人来在汇总统计数据中剪枝，因此可能缺少关于放置小于 4 次出价的机器人的数据。</li>
<li>也可能会错过地址不在 PGA 列表中的机器人，从而导致在某些拍卖中错过投标人。</li>
<li>工具通过解析支持交易所的交易日志来计算纯收入机会，这些交易日志包含由智能合约执行的两个以上交易。研究仅支持有限的流行 DEX 子集，忽略了不受支持的交易所的收入机会。实验支持的交易所包括基础设施开发时持续交易量排名前五的 DEX。</li>
</ul>
<h2 id="5-Observations"><a href="#5-Observations" class="headerlink" title="5 Observations"></a>5 Observations</h2><h3 id="市场规模"><a href="#市场规模" class="headerlink" title="市场规模"></a>市场规模</h3><ul>
<li>在 2017 年末的初始市场发展之后，出现了一个相对活跃的套利期，在此期间，机器人通常每天执行超过 1,000 笔交易，每日收入为 10-100 ETH。</li>
<li>后来，市场逐渐成熟，利润分配更加稳定一致，每天有 1-10 ETH 可供套利。</li>
<li>作者发文前期，观察到越来越多的纯收益交易，表明 DEX 市场的趋势是更小的零售交易和更高效的市场设计，降低了平均机会规模，但为更高效的机器人市场提供了更频繁的机会。</li>
<li>垂线：2017 年 8 月，作者发布了一份关于去中心化套利和相关机器人设计危险的初步报告。博客发布日期显示为图表上的垂直线。那篇文章中作者执行自己的交易机器人来确认利润的技术可行性，观察到为自己的机器人获取纯收入的成功率为 58%。在图 6 中，今天大多数盈利的机器人在作者公开发布后不久就加入了，这无意中引发了山寨机器人经济的繁盛！</li>
</ul>
<p><img src="/pics/flashboy2/4.png" alt="Fig 4"></p>
<h3 id="交易所收入"><a href="#交易所收入" class="headerlink" title="交易所收入"></a>交易所收入</h3><ul>
<li>图 5 显示了自 2018 年 4 月以来按交易所划分的纯收入市场细分（Etherdelta 以外的第一个重要纯收入机会，代表新的交易所上线）。</li>
<li>观察到一个寡头垄断的纯收入市场，其中  etherdelta 产生了大部分观察到的纯收入。</li>
<li>尽管如此，一系列其他交易所为机器人提供了越来越多且相对一致的机会分布。因为作者的调研只支持某些交易所，所以这张图可能会缺少不支持的交易所，市场总量只提供了一个下限。</li>
</ul>
<p><img src="/pics/flashboy2/5.png" alt="Fig 5"></p>
<h3 id="机器人收入"><a href="#机器人收入" class="headerlink" title="机器人收入"></a>机器人收入</h3><ul>
<li>图 6 显示了在竞争激烈的纯收入市场中观察到的前 10 名交易发送者及其相关利润。为这些机器人测量的成本仅包括它们进行的纯收入交易的 gas，因此可能会低估它们的总费用（例如失败的交易）。作者也不包括任何不在他们支持的交易所进行交易的机器人。</li>
<li>正如在交易所细分中一样，这个数字表明了一个寡头垄断市场，单个机器人通常在很长一段时间内主导利润空间（例如，0xaa24…主导着最近的纯收入空间，其中 0x0000…经历了很长一段时间2017 年底和 2018 年初的主导地位）。</li>
<li>顶级机器人在未能更新其策略后退出市场的行为。例如 0xa53… 在 03/18 左右退出，而 0xf13… 在 2017 年底市场早期退出。尽管如此，许多机器人享有长期的盈利能力，并继续运行多年。</li>
</ul>
<p><img src="/pics/flashboy2/6.png" alt="Fig 6"></p>
<h3 id="市场收入与利润"><a href="#市场收入与利润" class="headerlink" title="市场收入与利润"></a>市场收入与利润</h3><ul>
<li>图 7 描述了在优先 gas 拍卖中观察到的纯收入机会的利润和收入之间的细分，表明至少有一个机器人提出了竞争性的 gas 替代投标以抓住这样的机会。</li>
<li>虽然在 0 利润附近出现了峰值，这表明许多 PGA 机会对玩家来说是零或负和，但绝大多数这些机会的成本相对微不足道，而且利润分配仍然为获胜的机器人提供了平均利润，为他们提供了 大部分相关收入。</li>
<li>这证实了作者此前的怀疑，机器人可能参与不协调的合作，以牺牲矿工的利益来维持 PGA 市场的盈利能力。（这点没明白，是怎么从图上看出这点的。另外就是，根据直觉，竞争通过抬高 Gas 实现，那么矿工应该是获利才对，为什么作者说 PGA 市场的盈利能力是需要牺牲矿工的利益来维持？）</li>
</ul>
<p><img src="/pics/flashboy2/7.png" alt="Fig 7"></p>
<h3 id="PGA-中的-Gas-成本"><a href="#PGA-中的-Gas-成本" class="headerlink" title="PGA 中的 Gas 成本"></a>PGA 中的 Gas 成本</h3><ul>
<li>图 8 显示了随着时间的推移 gas 优化的趋势。在 04/18 之前，主要观察到 Etherdelta 趋势正如作者预期，结果显示机器人优化了他们的 gas 成本，随着时间的推移有明显的下降趋势，</li>
<li>但随着更复杂的交易所的出现表明市场成熟，执行的机会更复杂，每笔交易需要更多的 gas。每笔交易的交易数量也有所增加，现在平均每笔交易超过两笔交易。这种趋势的部分原因是由于像 Kyber 这样的“流动性池”交易所设计，它允许使用交易所合约作为在其他交易所进行交易的代理。</li>
<li>该图上的橙色虚线显示了作者公开发布的名为 GasToken 的代币。它利用了以太坊激励模型中的一项功能，使套利者能够随着时间的推移进行 gas 套利，以低于市场的价格储存 gas，并将其用于赢得 PGA。执行这种 gas 利的机制会向矿工提供数量出价的交易退款，从而诱使矿工接受低于预期的出价。因为允许机器人以相同的成本以更少的数量竞标更高的 gas 价格，所以这个代币现在是竞争参与纯收入套利市场的必要条件。这反映在这张趋势图中，在这种代币发行后，矿工对 gas 机器人的需求急剧下降。</li>
</ul>
<p><img src="/pics/flashboy2/8.png" alt="Fig 8"></p>
<h2 id="PGA-模型"><a href="#PGA-模型" class="headerlink" title="PGA 模型"></a>PGA 模型</h2><p>作者构建 PGA 模型形式化地研究 bot 间竞价的策略。作者的模型主要有下列属性，</p>
<ol>
<li>连续时间：玩家在连续的时间内行动，而不是离散的回合（如在典型的广泛形式游戏中）。 这是因为区块链网络是异步的。</li>
<li>信息不完善：玩家最终会看到彼此的出价，但不会立即看到，这是一种对区块链网络延迟进行建模的特征。玩家 Pi 在某个固定时间 Δi 后观察其他玩家的出价。玩家可能有不同的延迟，较小的延迟赋予竞争优势。作者将延迟测量为与矿工延迟的相对数字，这些矿工通常是网络中连接最好的节点。因此，Δi = 0 表明 Pi 具有优越的网络位置，并且可以观察其他玩家的出价，而不会比矿工的出价产生额外的延迟。</li>
<li>全部付费：在 PGA 中，失败的玩家为失败的交易支付 gas 费用。作者的模型通过让失败的玩家 P 支付 l($blast) 来捕获这一成本，其中 $blast 是 P 的最后一次出价，而 l() 是损失函数。这种玩家可以多次出价的拍卖被称为美元拍卖，其中不仅赢家，输家也要支付。在本研究中，作者通常观察到部分全额支付的拍卖，即 l($blast) &lt; $blast。</li>
<li>概率拍卖持续时间：拍卖在随机确定的时间终止，即下一个区块被开采时。对于以太坊等工作量证明区块链，作者将区块间隔建模为随机变量 D，它呈指数分布</li>
<li>限速出价：玩家不能连续提高自己的出价，必须等待很短的时间间隔 δ。这反映了区块链对等网络为防止 flooding 攻击而执行的节流。由于矿工总是可以自由地包含他们观察到的最高支付交易，因此玩家只能提高出价，而不是降低出价（以太坊 PGA 中的自然拍卖功能）</li>
<li>最低起拍价：虽然以太坊没有规定的最低 gas 价格，但在实践中，PGA 参与者希望以能够让他们有机会进入下一个区块的价格开始出价。(换句话说，如果一个人出价过低，那么即使没有其他人出价反对他们，矿工也可能不会将交易包含在他们的区块中。 )因此，虽然没有严格执行，但作者将拍卖建模为具有最低起拍价，s。</li>
<li>最小投标增量：玩家不能自由地以任意增量提高投标。取而代之的是，有一个最低加价 ι，它是作为玩家之前的出价的函数来衡量的。 这与以太坊动态相匹配，其中一个人可以用另一笔交易替换他们的交易，但只有当 gas 价格上涨了一个最低阈值时，它才会由点对点网络中继。 Parity 是最常见的以太坊节点软件，默认最小增量为 12:5%。</li>
</ol>
<h2 id="PGA-策略"><a href="#PGA-策略" class="headerlink" title="PGA 策略"></a>PGA 策略</h2><p>作者从策略空间中，选取三种竞标策略介绍。</p>
<ul>
<li><p>Binding Raising 盲目加注</p>
<ul>
<li>盲注是一种简单的非适应性策略。玩家 Pi 在预定的时间表下提高自己的出价，并且该策略对于其他玩家出价的历史是不变的。在观察到的 PGA 中，此计划通常涉及以固定的分数增量（例如，12.5%、21% 或 70%）重复增加。 因此，基本盲注也是确定性的（“纯”）。 </li>
<li>乍一看，这种策略和一般的非自适应策略似乎是个坏主意：它们无法利用 b∗ 中玩家可用的信息。 然而，网络延迟产生的不完美信息意味着非自适应策略可以比自然自适应策略获得优势。玩家可以更快地发布出价，而不是等待看到对方玩家的出价并做出反应。</li>
</ul>
</li>
<li><p>CounterBidding 对叫</p>
<ul>
<li>还价是一种策略，其中玩家观察对手的出价策略并通过提出更高的对方出价来做出反应。与盲目加注策略相比，反应性还价可以取得优势——尽可能快地以少量出价超过 P0，前提是出价提高了所需的最低限度。</li>
</ul>
</li>
<li><p>Cooperation 合作</p>
<ul>
<li>玩家缓慢交替提高出价。请注意，由于出价是非递减的，玩家每次连续提交出价，机会的最大盈利能力都会降低。减少游戏中的出价总数对所有玩家都是有益的。然后很自然地假设，只要有可能，玩家将在带外协调以分配利润，而不是通过在链上竞标来减少利润。 然而，实际情况是完美的合作并不存在。</li>
<li>链下协调<ul>
<li>在观察中，作者发现了许多只有一个参与者的套利机会，而且链下协调完全有可能在这里发挥作用，尽管就其本质而言，链上没有足够的数据来证实这一点。</li>
<li>虽然链下合作可能有意义，特别是在重复游戏中，但它有一些缺点，包括缺乏匿名性。</li>
</ul>
</li>
<li>研究表明，在合适的参数下，双方都存在纳什均衡以遵循合作策略。要使合作均衡出现，玩家不必明确地进行带外协调，但这种行为可以在链上有机地发展。事实上，观察结果表明，随着时间的推移，玩家已经更接近于合作平衡，这与实验博弈论中众所周知的结果一致，即野外参与者将随着时间的推移收敛到平衡。</li>
</ul>
</li>
</ul>
<h2 id="MEV"><a href="#MEV" class="headerlink" title="MEV"></a>MEV</h2><p>作者工作的一个关键结果是应用层安全对共识层安全构成了当前和直接的威胁。订单优化 (Order Optimization) 费用或矿工通过利用他们对共识时期的控制而能够获得的隐性费用，可能会超过区块奖励，反而会激励分叉攻击。为了获得 OO 费用，矿工可以重新排序用户的交易，并可能将他们自己的交易插入到他们的账户中，从而直接从 Ether 中获得利润。</p>
<h3 id="undercutting-attack"><a href="#undercutting-attack" class="headerlink" title="undercutting attack"></a>undercutting attack</h3><p>矿工可以分叉一个高费用的区块，保留一些费用以吸引其他矿工在分叉上进行构建。在极端情况下，偏离协议的动机可能会导致经济理性矿工的矿工策略中断，从而降低区块确认提供的安全性。</p>
<p><img src="/pics/flashboy2/9-1.png" alt="undercutting"><br><img src="/pics/flashboy2/9-2.png" alt="undercutting"></p>
<h3 id="time-bandit-attack"><a href="#time-bandit-attack" class="headerlink" title="time-bandit attack"></a>time-bandit attack</h3><p>假设一个区块链有一个（子链）[height0; height1]，当前区块高度 height1，其中可窃取的价值超过了区块奖励。对手可以回退到 height0 并使用由此产生的 MEV 来补贴可盈利的 51% 攻击，该攻击将分叉挖掘到或超过 height1。当然，time-bandit 攻击依赖于对海量挖矿资源的实时访问。使用云资源理论上是可行的，特别是对于像以太坊这样严重依赖 GPU 的系统，GPU 是标准的云商品。</p>
<p><img src="/pics/flashboy2/10-1.png" alt="time-bandit"><br><img src="/pics/flashboy2/10-2.png" alt="time-bandit"></p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p><strong>文章作者关注以太坊智能合约系统中的纯粹收入机会，该安全威胁使得套利机器人竞标这一场景存在，因此作者对该现象展开调研，并形成有关该场景的多个发现。同时作者认为，这一问题反映了另一个事实，就是应用层的安全威胁，实际上也会给底层（即共识层）带来安全威胁，具体而言，矿工会为了攫取利益而展开攻击从而影响共识层的公平性。作者从理论上分析了两种具体攻击的可行性，论证自己的观点。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/24/summary-flash-boy-2/" data-id="cl00xayiu0000egwxf8pg7cam" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/paperSummary/" rel="tag">paperSummary</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/19/test/" class="article-date">
  <time datetime="2022-02-19T06:08:45.000Z" itemprop="datePublished">2022-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/19/test/">【知识】【小程序】微信小程序代码分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>最近在逆向小程序的代码，主要目标是实现小程序静态分析工具，因此整理一下小程序包从获取、解包到代码结构的相关知识。</strong></p>
<h1 id="小程序包"><a href="#小程序包" class="headerlink" title="小程序包"></a>小程序包</h1><h2 id="wxapkg-包获取"><a href="#wxapkg-包获取" class="headerlink" title="wxapkg 包获取"></a>wxapkg 包获取</h2><p>安卓设备中存储在 /data/data/com.tencent.mm/MicroMsg/{UserIdHash}/appbrand/pkg/ 下 *.wxapkg</p>
<h2 id="wxapkg-包处理"><a href="#wxapkg-包处理" class="headerlink" title="wxapkg 包处理"></a>wxapkg 包处理</h2><p>二进制文件，没有对内容加密，没有对文件压缩，是各个数据段的拼接，比较好还原，各段如下图。头部含一些字段，比较重要的有数据段长度、文件数目。索引段表示各文件的文件名长度、文件名、文件在数据段的未知、文件大小等。数据段则是每个文件的文件数据。</p>
<p><img src="/pics/test/image.png" alt="小程序包结构"></p>
<h1 id="小程序代码结构"><a href="#小程序代码结构" class="headerlink" title="小程序代码结构"></a>小程序代码结构</h1><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>小程序的运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。<br>框架的核心是一个响应的数据绑定系统，可以让数据与视图非常简单地保持同步。当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。</p>
<p><img src="/pics/test/framework.png" alt="小程序框架结构"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- This is our View --&gt;</span><br><span class="line">&lt;view&gt; Hello &#123;&#123;name&#125;&#125;! &lt;/view&gt;</span><br><span class="line">&lt;button bindtap=&quot;changeName&quot;&gt; Click me! &lt;/button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// This is our App Service.</span><br><span class="line">// This is our data.</span><br><span class="line">var helloData = &#123;</span><br><span class="line">  name: &#x27;Weixin&#x27;</span><br><span class="line">&#125;</span><br><span class="line">// Register a Page.</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: helloData,</span><br><span class="line">  changeName: function(e) &#123;</span><br><span class="line">    // sent data change to view</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      name: &#x27;MINA&#x27;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h2><p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。一个小程序主体部分由三个文件组成，必须放在项目的根目录 app.json、app.js、app.wxss。</p>
<p><img src="/pics/test/packageStructure.png" alt="小程序包结构示例"></p>
<p>pages中代码构成 pages/xxx/index.[html | js | json | wxml]</p>
<p><img src="/pics/test/singlePage.png" alt="小程序包内单个页面路径下文件示例"></p>
<p>-json 后缀的 JSON 配置文件<br>-wxml 后缀的 WXML 模板文件<br>-wxss 后缀的 WXSS 样式文件<br>-js 后缀的 JS 脚本逻辑文件</p>
<h3 id="app-json"><a href="#app-json" class="headerlink" title="app.json"></a>app.json</h3><p>当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"># 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录</span><br><span class="line">  &quot;pages&quot;:[</span><br><span class="line">    &quot;pages/index/index&quot;,</span><br><span class="line">    &quot;pages/logs/logs&quot;</span><br><span class="line">  ],</span><br><span class="line"> # 定义小程序所有页面的顶部背景颜色，文字颜色定义等</span><br><span class="line">  &quot;window&quot;:&#123;</span><br><span class="line">    &quot;backgroundTextStyle&quot;:&quot;light&quot;,</span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;Weixin&quot;, # 通常理解为小程序名</span><br><span class="line">    &quot;navigationBarTextStyle&quot;:&quot;black&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="app-service"><a href="#app-service" class="headerlink" title="app.service"></a>app.service</h3><p>逻辑层将数据进行处理后发送给视图层，同时接受视图层的事件反馈。开发者写的所有代码最终将会打包成一份 JavaScript 文件，并在小程序启动的时候运行，直到小程序销毁。<br>在 JavaScript 的基础上，微信增加了一些功能（js-callgraph分析以此为基础）：<br>-增加 App 和 Page 方法，进行程序注册和页面注册。<br>-增加 getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈。<br>-提供丰富的 API，如微信用户数据，扫一扫，支付等微信特有能力。<br>-提供模块化能力，每个页面有独立的作用域。</p>
<p>app-service.js 是当前包中所有代码的汇总，之前介绍case时提到，解包解不出 pages/xxx/index.js时可以在 app-service.js中找到相应代码。</p>
<h3 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h3><p>每个小程序都需要在 app.js 中调用 App 方法注册小程序实例，绑定生命周期回调函数、错误监听和页面不存在监听函数等。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line">App(&#123;</span><br><span class="line">  onLaunch (options) &#123;</span><br><span class="line">    // Do something initial when launch.</span><br><span class="line">  &#125;,</span><br><span class="line">  onShow (options) &#123;</span><br><span class="line">    // Do something when show.</span><br><span class="line">  &#125;,</span><br><span class="line">  onHide () &#123;</span><br><span class="line">    // Do something when hide.</span><br><span class="line">  &#125;,</span><br><span class="line">  onError (msg) &#123;</span><br><span class="line">    console.log(msg)</span><br><span class="line">  &#125;,</span><br><span class="line">  globalData: &#x27;I am global data&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 getApp 方法获取到全局唯一的 App 实例，获取App上的数据或调用开发者注册在 App 上的函数。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// xxx.js</span><br><span class="line">const appInstance = getApp()</span><br><span class="line">console.log(appInstance.globalData) // I am global data</span><br></pre></td></tr></table></figure>

<h3 id="pages-xxx-index-js"><a href="#pages-xxx-index-js" class="headerlink" title="pages/xxx/index.js"></a>pages/xxx/index.js</h3><p>对于小程序中的每个页面，都需要在页面对应的 js 文件中进行注册，指定页面的初始数据、生命周期回调、事件处理函数等。简单的页面可以使用 Page() 进行构造。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    text: &quot;This is page data.&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function(options) &#123;</span><br><span class="line">    // 页面创建时执行</span><br><span class="line">  &#125;,</span><br><span class="line">  onShow: function() &#123;</span><br><span class="line">    // 页面出现在前台时执行</span><br><span class="line">  &#125;,</span><br><span class="line">  onReady: function() &#123;</span><br><span class="line">    // 页面首次渲染完毕时执行</span><br><span class="line">  &#125;,</span><br><span class="line">  onHide: function() &#123;</span><br><span class="line">    // 页面从前台变为后台时执行</span><br><span class="line">  &#125;,</span><br><span class="line">  onUnload: function() &#123;</span><br><span class="line">    // 页面销毁时执行</span><br><span class="line">  &#125;,</span><br><span class="line">  // 事件响应函数</span><br><span class="line">  viewTap: function() &#123;</span><br><span class="line">    this.setData(&#123;</span><br><span class="line">      text: &#x27;Set some data for updating view.&#x27;</span><br><span class="line">    &#125;, function() &#123;</span><br><span class="line">      // this is setData callback</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  // 自由数据</span><br><span class="line">  customData: &#123;</span><br><span class="line">    hi: &#x27;MINA&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Page 构造器适用于简单的页面。但对于复杂的页面， Page 构造器可能并不好用。<br>此时，可以使用 Component 构造器来构造页面。 Component 构造器的主要区别是：方法需要放在 methods: { } 里面。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    text: &quot;This is page data.&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    onLoad: function(options) &#123;</span><br><span class="line">      // 页面创建时执行</span><br><span class="line">    &#125;,</span><br><span class="line">    onPullDownRefresh: function() &#123;</span><br><span class="line">      // 下拉刷新时执行</span><br><span class="line">    &#125;,</span><br><span class="line">    // 事件响应函数</span><br><span class="line">    viewTap: function() &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h3><p>实现页面之间的切换</p>
<table>
<thead>
<tr>
<th align="left">路由方式</th>
<th align="center">触发时机</th>
<th align="right">路由前页面</th>
<th align="right">路由后页面</th>
</tr>
</thead>
<tbody><tr>
<td align="left">初始化</td>
<td align="center">小程序打开的第一个页面</td>
<td align="right"></td>
<td align="right">onLoad, onShow</td>
</tr>
<tr>
<td align="left">打开新页面</td>
<td align="center">调用 API wx.navigateTo  使用组件 <navigator open-type="navigateTo"/></td>
<td align="right">onHide</td>
<td align="right">onLoad, onShow</td>
</tr>
<tr>
<td align="left">页面重定向</td>
<td align="center">调用 API wx.redirectTo  使用组件 <navigator open-type="redirectTo"/></td>
<td align="right">onUnload</td>
<td align="right">onLoad, onShow</td>
</tr>
<tr>
<td align="left">页面返回</td>
<td align="center">调用 API wx.navigateBack  使用组件<navigator open-type="navigateBack">  用户按左上角返回按钮</td>
<td align="right">onUnload</td>
<td align="right">onShow</td>
</tr>
<tr>
<td align="left">Tab 切换</td>
<td align="center">调用 API wx.switchTab  使用组件 <navigator open-type="switchTab"/>  用户切换 Tab</td>
<td align="right"></td>
<td align="right"></td>
</tr>
<tr>
<td align="left">重启动</td>
<td align="center">调用 API wx.reLaunch  使用组件 <navigator open-type="reLaunch"/></td>
<td align="right">onUnload</td>
<td align="right">onLoad, onShow</td>
</tr>
</tbody></table>
<blockquote>
<p>参考资料<br><a target="_blank" rel="noopener" href="https://lrdcq.com/me/read.php/66.htm">https://lrdcq.com/me/read.php/66.htm</a><br><a target="_blank" rel="noopener" href="https://kangzubin.com/wxapp-decompile-1/">https://kangzubin.com/wxapp-decompile-1/</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/36710658">https://zhuanlan.zhihu.com/p/36710658</a><br><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/">https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/19/test/" data-id="ckztirwgq0000r0wx0n8wccvt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/02/19/hello-world/" class="article-date">
  <time datetime="2022-02-19T03:34:12.091Z" itemprop="datePublished">2022-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/02/19/hello-world/">【技术】【其他】Hexo 教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/02/19/hello-world/" data-id="ckztirwgz0001r0wxdr1r09hx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/BUG%E5%8F%8D%E6%80%9D/" rel="tag">BUG反思</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/paperSummary/" rel="tag">paperSummary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" rel="tag">小程序</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/BUG%E5%8F%8D%E6%80%9D/" style="font-size: 10px;">BUG反思</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/paperSummary/" style="font-size: 15px;">paperSummary</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 20px;">小程序</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/04/22/unpackwxError/">【工具】【小程序】wxUnpacker 工具“SyntaxError： Illegal return statement” 错误</a>
          </li>
        
          <li>
            <a href="/2022/04/15/apinath/">【工具】【小程序】Apinat 工具原理解析</a>
          </li>
        
          <li>
            <a href="/2022/03/31/miniscrawler/">【技术】【小程序】MiniScrawler 工具原理解析</a>
          </li>
        
          <li>
            <a href="/2022/03/24/esprimae/">【技术】【JS 静态分析】Javascript 分析工具 Esprima</a>
          </li>
        
          <li>
            <a href="/2022/03/17/Xposed/">【BUG 体质康复日记】尝试在 Android 10 安装 Xposed 踩的坑</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>